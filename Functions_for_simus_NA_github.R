library("MASS")
library("mvtnorm")

ImputeMean <- function(tab){
  m <- apply(tab, 2, mean, na.rm = TRUE)
  tab <- sapply(1:ncol(tab), function(x) ifelse(is.na(tab[,x]), m[x], tab[,x]))
  tab <- as.data.frame(tab)
  return(tab)
}


SimuZ <- function(n,pik){
  #######Arguments
  ##n: number of observations
  ##pik: vector of size K, proportion of the K classes
  #######Values
  ##Return a matrix of size (n,K), the partition
  
  K <- length(pik)
  Z <- matrix(0,nrow=n,ncol=length(pik))
  obs_pos <- 1:n
  for (k in 1:(K-1)){
    obs_k <- sample(obs_pos,pik[k]*n)
    Z[obs_k,k] <- 1
    obs_pos <- setdiff(obs_pos,obs_k)
  }
  Z[obs_pos,K] <- 1
  return(Z)
}

SimuY <- function(Z,d,pik,mu,sigma){
  #######Arguments
  ##Z: matrix of size (n,K) for the partition
  ##d: dimension of the observations
  ##pik: vector of size K, proportion of the K classes
  ##mu: list of length K where each element of the list contains a vector of size d: the means for the variables in the class K
  ##sigma: list of length K where each element of the list contains a matrix of size (d,d): the covariance matrices for the variables in the class K
  #######Values
  ##Return a Gaussian matrix generated by a mixture model with the partition Z. 
  
  K <- length(pik)
  n <- dim(Z)[1]
  Y_gauss <- matrix(NA,nrow=n,ncol=d)
  for (k in 1:K){
    obs_k <- which(Z[,k]==1)
    Y_gauss[obs_k, ] <- mvrnorm(n*pik[k] , mu[[k]] , sigma[[k]])
  }
  return(Y_gauss)
}

SimuYquali <- function(Z,d,pik,Proba){
  #######Arguments
  ##Z: matrix of size (n,K) for the partition
  ##d: dimension of the observations
  ##pik: vector of size K, proportion of the K classes
  ##Proba: list of length K where each element of the list contains a list of length d which contains vectors of size the number of levels per variable: the probability for the variable to be equal to a level in the class K
  #######Values
  ##Return a categorical matrix generated by a mixture model with the partition Z. 
  K <- length(pik)
  n <- dim(Z)[1]
  Y_quali <- matrix(0,nrow=n,ncol=d)
  for (k in 1:K){
    obs_k <- which(Z[,k]==1)
    for (j in 1:d){
      Y_quali[obs_k,j] <-  factor(apply(rmultinom(pik[k]*n,1,Proba[[k]][[j]]),2,which.max))
    }
  }
  return(Y_quali)
}



###### MNARz or MNARzj

Simulation_MNARnoty <- function(Y,Z,pik,probmiss,mecha,rho=NULL){
  n <- dim(Y)[1]
  d <- dim(Y)[2]
  K <- length(pik)
  C <- matrix(NA,nrow=n,ncol=d)
  if (rho=="logit"){
    if (mecha == "MNARz"){
      for (k in 1:K){
        obs_k <- which(Z[,k]==1)
        C[obs_k,] <-  matrix(runif(n*pik[k]*d,0,1) < 1/(1+exp(-probmiss[k])),ncol=d)
      }
    }else{
      for (k in 1:K){
        obs_k <- which(Z[,k]==1)
        for (j in 1:d){
          C[obs_k,j] = runif(n*pik[k],0,1) < 1/(1+exp(-probmiss[k,j]))
        }
      }
      # SimuC <- lapply(1:K, function(k){
      #   simC = matrix(TRUE,ncol=d,nrow=n*pik[k])
      #   for (j in 1:d){
      #     simC[,j] = runif(n*pik[k],0,1) < 1/(1+exp(-probmiss[k,j]))
      #   }
      #   return(simC)
      # })
    }
  }else if (rho=="probit"){
    if (mecha == "MNARz"){
      for (k in 1:K){
        obs_k <- which(Z[,k]==1)
        C[obs_k,] <-   matrix(runif(n*pik[k]*d,0,1) < pnorm(probmiss[k]),ncol=d)
      }
    }else{
      for (k in 1:K){
        obs_k <- which(Z[,k]==1)
        for (j in 1:d){
          C[obs_k,j] = runif(n*pik[k],0,1) < pnorm(probmiss_z[k,j])
        }
      }
      # SimuC <- lapply(1:K, function(k){
      #   simC = matrix(TRUE,ncol=d,nrow=n*pik[k])
      #   for (j in 1:d){
      #     simC[,j] = runif(n*pik[k],0,1) < pnorm(probmiss[k,j])
      #   }
      #   return(simC)
      # })
    }
  }else{
    if (mecha == "MNARz"){
      for (k in 1:K){
        obs_k <- which(Z[,k]==1)
        C[obs_k,] <-  matrix(runif(n*pik[k]*d,0,1) < probmiss[k],ncol=d)
      }
    }else{
      for (k in 1:K){
        obs_k <- which(Z[,k]==1)
        for (j in 1:d){
          C[obs_k,j] = runif(n*pik[k],0,1) < probmiss_z[k,j]
        }
      }
      # SimuC <- lapply(1:K, function(k){
      #   simC = matrix(TRUE,ncol=d,nrow=n*pik[k])
      #   for (j in 1:d){
      #     simC[,j] = runif(n*pik[k],0,1) < probmiss[k,j]
      #   }
      #   return(simC)
      # })
    }
  }
  #C <- Reduce(rbind,SimuC)
  return(C)
}


###### MNARyall

Simulation_MNARyall <- function(pik,Y,Z,probmiss_y,mecha,probmiss_z=NULL){
  if (is.matrix(Y)==TRUE){
    n <- dim(Y)[1]
    d <- dim(Y)[2] 
  }else{
    n <- length(Y)
    d <- 1
    Y <- matrix(Y)
  }
  K <- length(pik)
  #indmin <- cumsum(n*c(0,pik[1:K-1]))+1
  #indmax <- cumsum(n*pik)
  if (mecha == "MNARykzj"){
    SimuC = matrix(TRUE,ncol=d,nrow=n)
    for (k in 1:K){
      obs_k <- which(Z[,k]==1)
      for (j in 1:d){
        SimuC[obs_k,j] = runif(n*pik[k],0,1) < pnorm(probmiss_z[k,j]+probmiss_y[k,j]*Y[obs_k,j])
      }
    }
    # SimuC <- lapply(1:K, function(k){
    #   obs_k <- which(Z[,k]==1)
    #   simC = matrix(TRUE,ncol=d,nrow=n*pik[k])
    #   for (j in 1:d){
    #     simC[obs_k,j] = runif(n*pik[k],0,1) < pnorm(probmiss_z[k,j]+probmiss_y[k,j]*Y[obs_k,j])
    #   }
    #   return(simC)
    # })
  }else if(mecha == "MNARyzj"){
    SimuC = matrix(TRUE,ncol=d,nrow=n)
    for (k in 1:K){
      obs_k <- which(Z[,k]==1)
      for (j in 1:d){
        SimuC[obs_k,j] = runif(n*pik[k],0,1) < pnorm(probmiss_z[k,j]+probmiss_y[j]*Y[obs_k,j])
      }
    }
    # SimuC <- lapply(1:K, function(k){
    #   obs_k <- which(Z[,k]==1)
    #   simC = matrix(TRUE,ncol=d,nrow=n*pik[k])
    #   for (j in 1:d){
    #     simC[obs_k,j] = runif(n*pik[k],0,1) < pnorm(probmiss_z[k,j]+probmiss_y[j]*Y[obs_k,j])
    #   }
    #   return(simC)
    # })
  }else if(mecha == "MNARykz"){
    SimuC = matrix(TRUE,ncol=d,nrow=n)
    for (k in 1:K){
      obs_k <- which(Z[,k]==1)
      for (j in 1:d){
        SimuC[obs_k,j] = runif(n*pik[k],0,1) < pnorm(probmiss_z[k]+probmiss_y[k,j]*Y[obs_k,j])
      }
    }
    # SimuC <- lapply(1:K, function(k){
    #   obs_k <- which(Z[,k]==1)
    #   simC = matrix(TRUE,ncol=d,nrow=n*pik[k])
    #   for (j in 1:d){
    #     simC[obs_k,j] = runif(n*pik[k],0,1) < pnorm(probmiss_z[k]+probmiss_y[k,j]*Y[obs_k,j])
    #   }
    #   return(simC)
    # })
  }else if(mecha == "MNARyz"){
    SimuC = matrix(TRUE,ncol=d,nrow=n)
    for (k in 1:K){
      obs_k <- which(Z[,k]==1)
      for (j in 1:d){
        SimuC[obs_k,j] = runif(n*pik[k],0,1) < pnorm(probmiss_z[k]+probmiss_y[j]*Y[obs_k,j])
      }
    }
    # SimuC <- lapply(1:K, function(k){
    #   obs_k <- which(Z[,k]==1)
    #   simC = matrix(TRUE,ncol=d,nrow=n*pik[k])
    #   for (j in 1:d){
    #     simC[obs_k,j] = runif(n*pik[k],0,1) < pnorm(probmiss_z[k]+probmiss_y[j]*Y[obs_k,j])
    #   }
    #   return(simC)
    # })
  }else if(mecha == "MNARy"){
    SimuC = matrix(TRUE,ncol=d,nrow=n)
    for (j in 1:d){
      SimuC[,j] = runif(n,0,1) < pnorm(probmiss_y[j]*Y[,j])
    }
  }else if(mecha == "MNARyk"){
    SimuC = matrix(TRUE,ncol=d,nrow=n)
    for (k in 1:K){
      obs_k <- which(Z[,k]==1)
      for (j in 1:d){
        SimuC[obs_k,j] = runif(n*pik[k],0,1) < pnorm(probmiss_y[k,j]*Y[obs_k,j])
      }
    }
    # SimuC <- lapply(1:K, function(k){
    #   obs_k <- which(Z[,k]==1)
    #   simC = matrix(TRUE,ncol=d,nrow=n*pik[k])
    #   for (j in 1:d){
    #     simC[obs_k,j] = runif(n*pik[k],0,1) < pnorm(probmiss_y[k,j]*Y[obs_k,j])
    #   }
    #   return(simC)
    # })
  }else{
    stop("This mechanism is unknown. ")
  }
  #if (mecha == "MNARy" | mecha == "MNARyz" | mecha == "MNARyk"){
    #C <- SimuC
  #}else{
  #  C <- Reduce(rbind,SimuC)
  #}
  return(SimuC)
}
