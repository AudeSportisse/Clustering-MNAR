######
# Name: SimuZ
# Date: 2021/01/01
# Description:
# Arguments:
## n: number of observations (numeric)
## pik: true proportion of the K classes (vector of size K)
#####

SimuZ <- function(n,pik){
  K <- length(pik)
  Z <- matrix(0,nrow=n,ncol=length(pik))
  obs_pos <- 1:n
  for (k in 1:(K-1)){
    obs_k <- sample(obs_pos,pik[k]*n)
    Z[obs_k,k] <- 1
    obs_pos <- setdiff(obs_pos,obs_k)
  }
  Z[obs_pos,K] <- 1
  return(Z)
}


######
# Name: SimuY
# Date: 2021/01/01
# Description: this function returns a Gaussian matrix generated by a mixture model with the partition Z. 
# Arguments:
## Z: partition (data matrix of size n,K)
## d: dimension of the observations (numeric)
## pik: true proportion of the K classes (vector of size K)
## mu: true value of the means (list of length K, with vectors of size d)
## sigma: true value of the covariance matrices (list of length K, with matrices of size d,d)
#####


SimuY <- function(Z,d,pik,mu,sigma){
  K <- length(pik)
  n <- dim(Z)[1]
  Y_gauss <- matrix(NA,nrow=n,ncol=d)
  for (k in 1:K){
    obs_k <- which(Z[,k]==1)
    Y_gauss[obs_k, ] <- mvrnorm(n*pik[k] , mu[[k]] , sigma[[k]])
  }
  return(Y_gauss)
}


######
# Name: SimuC
# Date: 2021/01/01
# Description: this function returns a Gaussian matrix generated by a mixture model with the partition Z. 
# Arguments:
## pik: true proportion of the K classes (vector of size K)
## Z: true partition (data matrix of size n,K)
## Y: data matrix with no missing values (size n,d)
## mecha: mechanism to use, "MNARz", "MNARy" or "MNARyz" (character)
## probmiss_y: true parameter for the mechanism, effect of the values of the variables (vector of size d)
## probmiss_z: true parameter for the mechanism, effect of the class membership (vector of size K)
#####



SimuC <- function(pik,Y,Z,mecha,probmiss_y=NULL,probmiss_z=NULL,intercept_y=NULL){
  if(is.null(probmiss_y) & is.null(probmiss_z)){
    return("error: no parameter for the mechanism is given.")
  }
  if (is.matrix(Y)==TRUE){
    n <- dim(Y)[1]
    d <- dim(Y)[2] 
  }else{
    n <- length(Y)
    d <- 1
    Y <- matrix(Y)
  }
  K <- length(pik)
  C = matrix(TRUE,ncol=d,nrow=n)
  
  if(mecha == "MNARz"){
    for (k in 1:K){
      obs_k <- which(Z[,k]==1)
      C[obs_k,] <-   matrix(runif(length(obs_k)*d,0,1) < pnorm(probmiss_z[k]),ncol=d)
    }
  }else if(mecha == "MNARzj"){
    for (k in 1:K){
      obs_k <- which(Z[,k]==1)
      for (j in 1:d){
        C[obs_k,j] = runif(length(obs_k),0,1) < pnorm(probmiss_z[k,j])
      }
    }
  }else if(mecha == "MNARyz"){
    for (k in 1:K){
      obs_k <- which(Z[,k]==1)
      for (j in 1:d){
        C[obs_k,j] = runif(length(obs_k),0,1) < pnorm(probmiss_z[k]+probmiss_y[j]*Y[obs_k,j])
      }
    }
  }else if(mecha == "MNARy"){
    for (j in 1:d){
      C[,j] = runif(n,0,1) < pnorm(intercept_y+probmiss_y[j]*Y[,j])
    }
  }else if (mecha=="MNARykzj"){
    for (k in 1:K){
      obs_k <- which(Z[,k]==1)
      for (j in 1:d){
        C[obs_k,j] = runif(length(obs_k),0,1) < pnorm(probmiss_z[k,j]+probmiss_y[k,j]*Y[obs_k,j])
      }
    }
  }else if(mecha=="MNARyzj"){
    for (k in 1:K){
      obs_k <- which(Z[,k]==1)
      for (j in 1:d){
        C[obs_k,j] = runif(length(obs_k),0,1) < pnorm(probmiss_z[k,j]+probmiss_y[j]*Y[obs_k,j])
      }
    }
  }else if(mecha=="MNARykz"){
    for (k in 1:K){
      obs_k <- which(Z[,k]==1)
      for (j in 1:d){
        C[obs_k,j] = runif(length(obs_k),0,1) < pnorm(probmiss_z[k]+probmiss_y[k,j]*Y[obs_k,j])
      }
    }
  }else if(mecha == "MNARyk"){
    for (k in 1:K){
      obs_k <- which(Z[,k]==1)
      for (j in 1:d){
        C[obs_k,j] = runif(length(obs_k),0,1) < pnorm(intercept_y+probmiss_y[k,j]*Y[obs_k,j])
      }
    }
  }

  return(C)  
}


######
# Name: Mechanism_SEM_GLM
# Date: 2021/12/21
# Description:
# Arguments:
## YNA: matrix containing missing values (data matrix of size n,d)
## Y: current imputed matrix (data matrix of size n,d)
## Z: current partition (data matrix of size n,K)
## mecha: mechanism to use, "MCAR", "MNARz", "MNARy" or "MNARyz" (character)
#####


Mechanism_SEM_GLM <- function(YNA,Y,Z,mecha){
  
  n <- dim(YNA)[1]
  d <- dim(YNA)[2]
  K <- dim(Z)[2]
  C <- matrix(as.numeric(is.na(YNA)),ncol=ncol(YNA))
  
  if(mecha == "MNARz"){
    
    J_MNARz <- data.frame(c(C))
    names(J_MNARz) <- "Indicator"
    Z.new_dataframe <- data.frame(Z)
    names(Z.new_dataframe) <- paste0("Class",1:K)
    J_MNARz <- cbind.data.frame(J_MNARz,Z.new_dataframe)
    GLMfit <- glm(as.formula(paste0("Indicator~-1+",paste0("Class",1:K,collapse="+"))), family=binomial(link="probit"), data=J_MNARz)
    alpha.new <- matrix(rep(c(GLMfit$coefficients),d),ncol=d)
    beta.new <- matrix(0,nrow=K,ncol=d)
    
  }else if(mecha == "MNARzj"){
    
    alpha.new <- matrix(0,nrow=K,ncol=d)
    beta.new <- matrix(0,nrow=K,ncol=d)
    for (j in 1:d){
      J_MNARzj <- data.frame(C[,j])
      names(J_MNARzj) <- "Indicator"
      Z.new_dataframe <- data.frame(Z)
      names(Z.new_dataframe) <- paste0("Class",1:K)
      J_MNARzj <- cbind.data.frame(J_MNARzj,Z.new_dataframe)
      if (rho=="logit"){
        GLMfit <- glm(as.formula(paste0("Indicator~-1+",paste0("Class",1:K,collapse="+"))), family=binomial(link="logit"), data=J_MNARzj)
      }else{
        GLMfit <- glm(as.formula(paste0("Indicator~-1+",paste0("Class",1:K,collapse="+"))), family=binomial(link="probit"), data=J_MNARzj)
      }
      alpha.new[,j] <- GLMfit$coefficients
    }
    
  }else if(mecha=="MNARyz"){
    
    J_MNARz <- data.frame(c(C))
    Z.new_dataframe <- data.frame(Z)
    J_MNARz <- cbind.data.frame(J_MNARz,Z.new_dataframe)
    tab <- matrix(0,ncol=d,nrow=n*d)
    for (j in 1:d){
      tab[(1+(n*(j-1))):(n*j),j] <- Y[,j]
    }
    J_MNARz <- cbind(J_MNARz,tab)
    names(J_MNARz) <- c("Indicator",paste0("Class",1:K),paste0("Variable",1:d))
    GLMfit <- glm(Indicator~.-1, family=binomial(link="probit"), data=J_MNARz)
    alpha.new <- matrix(rep(c(GLMfit$coefficients[1:K]),d),ncol=d)
    beta.new <- matrix(rep(c(GLMfit$coefficients[(K+1):(K+d)]),K),ncol=d,byrow=T)
  
  }else if(mecha=="MNARy"){
    
    J_MNARy <- data.frame(c(C))
    names(J_MNARy) <- "Indicator"
    tab <- matrix(0,ncol=d,nrow=n*d)
    for (j in 1:d){
      tab[(1+(n*(j-1))):(n*j),j] <- Y[,j]
    }
    J_MNARy <- cbind(J_MNARy,tab)
    names(J_MNARy) <- c("Indicator",paste0("Variable",1:d))
    GLMfit <- glm(Indicator~., family=binomial(link="probit"), data=J_MNARy)
    alpha.new <- matrix(GLMfit$coefficients[1],nrow=K,ncol=d)
    beta.new <- matrix(rep(GLMfit$coefficients[2:(d+1)],K),ncol=d,nrow=K,byrow=TRUE)
  
  }else if (mecha=="MNARykzj"){
    
    alpha.new <- matrix(0,nrow=K,ncol=d)
    beta.new <- matrix(0,nrow=K,ncol=d)
    for (k in 1:K){
      for (j in 1:d){
        Obs_classk <- which(Z[,k]==1)
        J_MNARyk <- data.frame(C[Obs_classk,j])
        names(J_MNARyk) <- "Indicator"
        Y.new_dataframe <- data.frame(Y[Obs_classk,j])
        names(Y.new_dataframe) <- "Variable"
        J_MNARyk <- cbind.data.frame(J_MNARyk,Y.new_dataframe)
        GLMfit <- glm(as.formula(paste0("Indicator~Variable")), family=binomial(link="probit"), data=J_MNARyk)
        alpha.new[k,j] <- GLMfit$coefficients[1]
        beta.new[k,j] <- GLMfit$coefficients[2]
      }
    }
    
  }else if(mecha=="MNARyzj"){
    
    alpha.new <- matrix(0,nrow=K,ncol=d)
    beta.new <- matrix(0,nrow=K,ncol=d)
    for (j in 1:d){
      J_MNARzj <- data.frame(C[,j])
      names(J_MNARzj) <- "Indicator"
      Z.new_dataframe <- data.frame(Z)
      names(Z.new_dataframe) <- paste0("Class",1:K)
      J_MNARzj <- cbind.data.frame(J_MNARzj,Z.new_dataframe)
      Y.new_dataframe <- data.frame(Y[,j])
      names(Y.new_dataframe) <- "Variable"
      J_MNARy <- cbind.data.frame(J_MNARzj,Y.new_dataframe)
      GLMfit <- glm(as.formula(paste0("Indicator~-1+Variable+",paste0("Class",1:K,collapse="+"))), family=binomial(link="probit"), data=J_MNARy)
      beta.new[,j] <- rep(GLMfit$coefficients[1],K)
      alpha.new[,j] <- GLMfit$coefficients[2:(K+1)]
    }
    
  }else if(mecha=="MNARykz"){
    
    alpha.new <- matrix(0,nrow=K,ncol=d)
    beta.new <- matrix(0,nrow=K,ncol=d)
    for (k in 1:K){
      Obs_classk <- which(Z[,k]==1)
      J_MNARyk <- data.frame(c(C[Obs_classk,]))
      tab <- matrix(0,ncol=d,nrow=length(Obs_classk)*d)
      for (j in 1:d){
        tab[(1+(length(Obs_classk)*(j-1))):(length(Obs_classk)*j),j] <- Y[Obs_classk,j]
      }
      J_MNARyk <- cbind(J_MNARyk,tab)
      names(J_MNARyk) <- c("Indicator",paste0("Variable",1:d))
      GLMfit <- glm(as.formula(paste0("Indicator~.")), family=binomial(link="probit"), data=J_MNARyk)
      beta.new[k,] <- GLMfit$coefficients[2:(d+1)]
      alpha.new[k,] <- rep(GLMfit$coefficients[1],d)
    }
    
  }else if(mecha == "MNARyk"){
    
    alpha.new <- matrix(0,nrow=K,ncol=d)
    beta.new <- matrix(0,nrow=K,ncol=d)
    
    J_MNARyk <- data.frame(c(C))
    tab <- matrix(0,ncol=K*d,nrow=n*d)
    ind_j <- 1
    ind_dep <- 0
    ind_fin <- 0
    namesJ <- c("Indicator")
    for (j in 1:d){
      for (k in 1:K){
        Obs_classk <- which(Z[,k]==1) 
        ind_fin <- ind_dep + length(Obs_classk)
        tab[(ind_dep+1):ind_fin,ind_j] <- Y[Obs_classk,j]
        ind_dep <- ind_dep + length(Obs_classk)
        ind_j <- ind_j + 1
        namesJ <- c(namesJ,paste0("Variable",k,j))
      }
    }
    J_MNARyk <- cbind(J_MNARyk,tab)
    names(J_MNARyk) <- namesJ
    GLMfit <- glm(Indicator~., family=binomial(link="probit"), data=J_MNARyk)
    beta.new <- matrix(GLMfit$coefficients[2:((K*d)+1)],nrow=K,ncol=d)
    alpha.new <- matrix(GLMfit$coefficients[1],nrow=K,ncol=d)

  }
  
  return(list(alpha.new=alpha.new,beta.new=beta.new))
  
}

######
# Name: Mechanism_EM_GLM
# Date: 2021/12/27
# Description:
# Arguments:
## YNA: matrix containing missing values (data matrix of size n,d)
## tik: current weights (data matrix of size n,K)
## mecha: mechanism to use, "MNARz" or "MNARzj" (character)
#####

Mechanism_EM_GLM <- function(YNA,tik,mecha){
  
  n <- dim(YNA)[1]
  d <- dim(YNA)[2]
  K <- dim(tik)[2]
  C <- matrix(as.numeric(is.na(YNA)),ncol=ncol(YNA))
  alpha.new <- matrix(0,nrow=K,ncol=d)
  
  if (mecha == "MNARz"){
    
    for (k in 1:K){
      GLMfit <- glm(c(C)~rep(1,n*d)-1, family=binomial(link="probit"), weights = rep(tik[,k],d))
      alpha.new[k,] <- rep(c(GLMfit$coefficients),d)
    }
    
  }else if(mecha == "MNARzj"){
    
    for (j in 1:d){
      for (k in 1:K){
        GLMfit <- glm(C[,j]~rep(1,n)-1, family=binomial(link="probit"), weights = tik[,k])
        alpha.new[k,j] <- GLMfit$coefficients
      }
    }
    
  }
  
  return(alpha.new)
  
}



######
# Name: ARI
# Date: 2021/12/21
# Description: this function computes the Adjusted Rand Index
# Arguments:
## x: vector defining a partition.
## y: vector defining a partition of whose length is equal to the length of x.
#####


ARI <- function (x, y){
  #### Tests on the input arguments
  if ((length(x) != length(y)))
    stop("The two partitions must be vectors of same length")
  
  ####
  
  ari <- 0
  if ((length(unique(x)) + length(unique(y))) == 2) ari <- 1
  conting <- table(x, y)
  a <- sum(choose(conting, 2))
  b <- sum(choose(rowSums(conting), 2)) - a
  c <- sum(choose(colSums(conting), 2)) - a
  d <- choose(sum(conting), 2) - a - b - c
  ari <- (a - (a + b) * (a + c)/(a + b + c + d))/((a + b +
                                                     a + c)/2 - (a + b) * (a + c)/(a + b + c + d))
  return(ari)
}
